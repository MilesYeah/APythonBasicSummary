


* xrange和range的区别？
  * python２里，有两种方法获得一定范围内的数字：range(),返回一个列表，还有xrange(),返回一个迭代器。
  * python3　里，range()返回迭代器，xrange()不再存在。
* 字节码和机器码的区别？
  * 机器码：是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂
  * 字节码：是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。
* python递归的最大层数？
  * 默认 1000
  * sys.getrecursionlimit()
  * sys.setrecursionlimit(num)
* 谈谈你对闭包的理解？
  * 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。
  * 一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。
  * 但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。
* 谈谈你对面向对象的理解？
  * 面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，
  * 不存在的也可以创造出来。对象是特征和技能的结合，其中特征和技能分别对应对象的数据属性和方法属性。
  * 优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。
  * 缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，
  * 面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。
  * 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。
* Python面向对象中的继承有什么特点？
  * 在继承中基类的构造(__init__()方法)不会被自动调用，它需要在其派生类的构造中亲自专门调用。
  * 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数
  * Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。(先在本类中查找调用的方法，找不到才去基类中找)。
* 如何判断是函数还是方法？其区别
  * `区别`：方法更偏重类中的设计层面， 函数更偏重于程序运行过程是的一种称谓
* 什么是反射？以及应用场景？
  * 定义：通过用字符串数据类型的变量名来访问这个变量的值，在python面向对象中的反射,通过字符串的形式操作对象相关的属性或方法.
  * 应用场景：用于处理通过用户输入，文件读取，或者网络传输所得到的字符串形式的指令来完成对应的操作
* metaclass作用？以及应用场景？
  * metaclass，直译为元类，简单的解释就是：当我们定义了类以后，就可以根据这个类创建出实例，
  * 所以：先定义类，然后创建实例。但是如果我们想创建出类呢？那就必须根据metaclass创建出类，
  * 所以：先定义metaclass，然后创建类。换句话说，你可以把类看成是metaclass创建出来的“实例”

* Python垃圾回收机制？
  * python采用的是引用计数机制为主，标记-清除和分代收集(隔代回收、分代回收)两种机制为辅的策略
  * 计数机制
    * Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”
    * 解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。
  * 标记-清除：
    * 标记-清除的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象
    * 缺点：该机制所带来的额外操作和需要回收的内存块成正比。
  * 隔代回收
    * 原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，
    * 垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，
    * 就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，
    * 如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。
* 是否使用过functools中的函数？其作用是什么？
  * functools用于高阶函数：
  * 指那些作用于函数或者返回其他函数的函数。
  * 通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标。
* 静态方法和类方法区别？
  * 静态方法：是既不是用类中的属性又不使用对象中的属性，由类或者对象调用的方法，依赖python装饰器@staticmethod来实现
    * 没有必要加入类似self或者是cls之类的必须的变量名
    * 静态方法不可以直接访问类变量，需要使用ClassName.VarName来调用类变量
    * 静态方法不可以直接访问实例变量
  * 类方法：只使用类中的静态变量，一般都是由类调用，依赖python装饰器@classmethod来实现
* 面向对象中的特殊成员以及应用场景？
  * __call__：对象的构造方法，对象加上()，可以触发这个类的__call__方法。
  * __len__：内置函数的len函数是依赖类中的__len__方法
  * __eq__：判断值是否相等的时候依赖__eq__方法
  * __hash__:判断hash值是否相等的时候依赖__hash__方法(拓展：set的去重机制其实就是根据__hash__和__eq__方法实现的)
  * __str__：和str() print() %s 都是息息相关的，返回值一定是字符串类型
  * __repr__：和 repr() %r都是息息相关的，在没有__str__方法时，__repr__可以完全取代__str__。
  * __del__ 析构方法，对应着一个对象的删除之前执行的内容
* yield和yield from关键字
  * yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器当你调用这个函数的时候，
    * 函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象，当你使用for进行迭代的时候，
    * 函数中的代码才会执行
  * yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，
    * 这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。
    * 有了这个结构，协程可以通过以前不可能的方式委托职责。
  * 更多解析详见：http://blog.gusibi.com/post/python-coroutine-yield-from/







-----------------------------------------------------------------------
## Ref
* [python基础(81道题)面试题，再也不用为没有答案发愁了](https://www.jianshu.com/p/7993d0e4e31c?tdsourcetag=s_pcqq_aiomsg)
* []()
* []()
* []()
* []()
* []()
* []()
* []()