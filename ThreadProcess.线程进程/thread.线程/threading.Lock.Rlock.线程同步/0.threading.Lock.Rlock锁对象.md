# threading.Lock.Rlock锁对象

### class threading.Lock 原始锁
1. acquire(blocking=True, timeout=- 1)
   1. 可以阻塞或非阻塞地获得锁。
   2. 当调用时参数 blocking 设置为 True （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 True 。
   3. 在参数 blocking 被设置为 False 的情况下调用，将不会发生阻塞。
   4. 如果调用时 blocking 设为 True 会阻塞，并立即返回 False ；
   5. 否则，将锁锁定并返回 True。
2. release()
   1. 释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。
   2. 当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。
   3. 当在未锁定的锁上发起调用时，会引发 RuntimeError。
   4. 没有返回值。
3. locked()
   1. 当线程被锁时返回 True

#### 杂话
1. 原始锁处于 "锁定" 或者 "非锁定" 两种状态之一。它被创建时为非锁定状态。
   1. 它有两个基本方法， 
      1. acquire()
      2. release() 。
   2. 当状态为非锁定时， acquire() 将状态改为 锁定 并立即返回。
   3. 当状态是锁定时， 
      1. acquire() 将阻塞至其他线程调用 release() 将其改为非锁定状态，
      2. 然后 acquire() 调用重置其为锁定状态并返回。 
   4. release() 只在锁定状态下调用； 它将状态改为非锁定并立即返回。
2. 如果尝试释放一个非锁定的锁，则会引发 RuntimeError  异常。
3. 锁同样支持 上下文管理协议。
4. 所有方法的执行都是原子性的。


### class threading.RLock 递归锁
1. acquire(blocking=True, timeout=- 1)
   1. 可以阻塞或非阻塞地获得锁。
   2. 当无参数调用时： 
      1. 如果这个线程已经拥有锁，递归级别增加一，并立即返回。
      2. 否则，如果其他线程拥有该锁，则阻塞至该锁解锁。
   3. 一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。
   4. 如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。
2. release()
   1. 释放锁，自减递归等级。
      1. 如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，
      2. 并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。
      3. 如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。
   2. 只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 RuntimeError 异常。
   3. 没有返回值。


重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 "所属线程" 和 "递归等级" 的概念。
1. 在锁定状态下，某些线程拥有锁 ； 
2. 在非锁定状态下， 没有线程拥有它。

若要锁定锁，线程调用其 acquire() 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 release() 方法。 
acquire()/release() 对可以嵌套；只有最终 release() (最外面一对的 release() ) 将锁解开，才能让其他线程继续处理 acquire() 阻塞。

递归锁也支持 上下文管理协议。

此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。

RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。

可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire()/release()，计数器将+1/-1，为0时锁处于未锁定状态。

注意：如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。



## 杂话




