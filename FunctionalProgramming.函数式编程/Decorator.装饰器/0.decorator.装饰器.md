
# decorator 装饰器

若想真正理解装饰器，需要区分导入时和运行时，还要知道变量作用域、闭包和新增的 nonlocal 声明。掌握闭包和 nonlocal 不仅对构建装饰器有帮助，还能协助你在构建 GUI 程序时面向事件编程，或者使用回调处理异步 I/O。

函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了 Python 程序员所说的导入时和运行时之间的区别。

Python 函数装饰器符合 Gamma 等人在《设计模式：可复用面向对象软件的基础》一书中对“装饰器”模式的一般描述：“动态地给一个对象添加一些额外的职责。就扩展功能而言，装饰器模式比子类化更灵活。”

## @classmethod修饰符对应的函数
* 不需要实例化，
* 不需要self参数，
* 第一个参数需要是表示自身类的cls参数，
* cls参数可以**用来调用类的属性，类的方法，实例化对象等**。


## @staticmethod
* 返回函数的静态方法，
* 该方法不强制要求传递参数，如下声明一个静态方法
    ```py
    Class C(object):
        @staticmethod
        def f(arg1, arg2,…):
            pass
    # 以上实例声明了静态方法f，类可以不用实例化就可以调用该方法C.f()，也可以实例化后调用C().f()。
    ```






## Ref
* [简单地理解 Python 的装饰器](https://www.itcodemonkey.com/article/814.html)
* [看完这篇文章还不懂Python装饰器？掐死小编吧](https://www.itcodemonkey.com/article/5156.html)
* [流畅的Python]7.12
* []()
* []()
* []()
* []()