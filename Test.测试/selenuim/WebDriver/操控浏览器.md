# 操控浏览器



## 浏览器导航

### 打开网站

启动浏览器后你要做的第一件事就是打开你的网站。这可以通过一行代码实现:

driver.get("https://selenium.dev")

### 获取当前 URL

driver.current_url

### 后退

driver.back()


### 前进

driver.forward()

### 刷新

driver.refresh()


### 获取标题

driver.title





## 窗口和标签页

```py
driver.current_window_handle
```

### 切换窗口或标签页

```py
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# 启动驱动程序
with webdriver.Firefox() as driver:
# 打开网址
driver.get("https://seleniumhq.github.io")

# 设置等待
wait = WebDriverWait(driver, 10)

# 存储原始窗口的 ID
original_window = driver.current_window_handle

# 检查一下，我们还没有打开其他的窗口
assert len(driver.window_handles) == 1

# 单击在新窗口中打开的链接
driver.find_element(By.LINK_TEXT, "new window").click()

# 等待新窗口或标签页
wait.until(EC.number_of_windows_to_be(2))

# 循环执行，直到找到一个新的窗口句柄
for window_handle in driver.window_handles:
    if window_handle != original_window:
        driver.switch_to.window(window_handle)
        break

# 等待新标签页完成加载内容
wait.until(EC.title_is("SeleniumHQ Browser Automation"))
```


### 创建新窗口(或)新标签页并且切换

```py
# 打开新标签页并切换到新标签页
driver.switch_to.new_window('tab')

# 打开一个新窗口并切换到新窗口
driver.switch_to.new_window('window')
```


### 关闭窗口或标签页

```py
#关闭标签页或窗口
driver.close()

#切回到之前的标签页或窗口
driver.switch_to.window(original_window)
```


### 在会话结束时退出浏览器

```py
driver.quit()
```

退出将会
* 关闭所有与 WebDriver 会话相关的窗口和选项卡
* 结束浏览器进程
* 结束后台驱动进程
* 通知 Selenium Grid 浏览器不再使用，以便可以由另一个会话使用它(如果您正在使用 Selenium Grid)


调用 quit() 失败将留下额外的后台进程和端口运行在机器上，这可能在以后导致一些问题。

有的测试框架提供了一些方法和注释，您可以在测试结束时放入 teardown() 方法中。

```py
# unittest teardown
# https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown
def tearDown(self):
    self.driver.quit()
```

如果不在测试上下文中运行 WebDriver，您可以考虑使用 try / finally，这是大多数语言都提供的， 这样一个异常处理仍然可以清理 WebDriver 会话。

```py
try:
    #WebDriver 代码…
finally:
    driver.quit()
```

Python 的 WebDriver 现在支持 Python 上下文管理器，当使用 with 关键字时，可以在执行结束时自动退出驱动程序。
```py
with webdriver.Firefox() as driver:
  # WebDriver 代码…

# 在此缩进位置后 WebDriver 会自动退出
```



## Frames and Iframes

框架是一种现在已被弃用的方法，用于从同一域中的多个文档构建站点布局。除非你使用的是 HTML5 之前的 webapp，否则你不太可能与他们合作。内嵌框架允许插入来自完全不同领域的文档，并且仍然经常使用。


### 使用 WebElement

### 使用 name 或 id


### 使用索引


### 离开框架







## 窗口管理


### 获取窗口大小

```py
# 分别获取每个尺寸
width = driver.get_window_size().get("width")
height = driver.get_window_size().get("height")

# 或者存储尺寸并在以后查询它们
size = driver.get_window_size()
width1 = size.get("width")
height1 = size.get("height")
```

### 设置窗口大小
```py
driver.set_window_size(1024, 768)
```


### 得到窗口的位置

```py
# 分别获取每个尺寸
x = driver.get_window_position().get('x')
y = driver.get_window_position().get('y')

# 或者存储尺寸并在以后查询它们
position = driver.get_window_position()
x1 = position.get('x')
y1 = position.get('y')
```


## 设置窗口位置

```py
# 将窗口移动到主显示器的左上角
driver.set_window_position(0, 0)
```

### 最大化窗口
```py
driver.maximize_window()
```

### 最小化窗口
```py
driver.minimize_window()
```

### 全屏窗口
```py
driver.fullscreen_window()
```

### 屏幕截图

```py
from selenium import webdriver

driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")

# Returns and base64 encoded string into image
driver.save_screenshot('./image.png')

driver.quit()
```


### 元素屏幕截图

```py
from selenium import webdriver
from selenium.webdriver.common.by import By

driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")

ele = driver.find_element(By.CSS_SELECTOR, 'h1')

# Returns and base64 encoded string into image
ele.screenshot('./image.png')

driver.quit()
```


### 执行脚本

在当前frame或者窗口的上下文中，执行JavaScript代码片段.
```py
import time
from time import sleep

from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.csdn.net/')

el = driver.find_element_by_link_text("Python")

driver.execute_script('$(arguments[0]).fadeOut()', el)
sleep(1)
driver.execute_script('$(arguments[0]).fadeIn()', el)

sleep(2)
driver.quit()
```



### 打印页面

```py
from selenium.webdriver.common.print_page_options import PrintOptions

print_options = PrintOptions()
print_options.page_ranges = ['1-2']

driver.get("printPage.html")

base64code = driver.print_page(print_options)
```

