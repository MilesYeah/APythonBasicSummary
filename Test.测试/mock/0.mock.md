# mock



## Mock概念
Mock:模拟部分功能实现,伪实现,接口测试时,可以实现伪接口

## Mock作用
1. 可以解除一些第三方依赖关系,方便测试
2. 模拟程序中出现的一些异常,尤其是小概率的异常事件(并发实现时,异常抛出是小概率)
3. 由于前后端开发进度不一致，如果前段开发速度快于后端，这时候需要一个假的接口用于模拟后端返回
4. 由于项目需要用到第三方接口，如果第三方接口未开发完成或者第三方接口没有测试环境，为了保证进度，需要模拟接口调试

## Mock实现方式
1. 白盒: 修改代码
2. 黑盒: 创建 Mock 服务, 让 Mock 服务模拟接口实现

##  Python Mock实现
1. 安装Mock, pip install mock( Python3.3之前需要安装,之后整合进 unittest了)
2. 确定被模拟的接口功能
3. 创建mock对象,设置被模拟的接口的返回数据
4. 调用,调用时调用mock对象


## 测试桩
有时候，在测试过程中，可能会用到测试桩。举个例子，模块A是我们的被测试系统，但是模块A需要从模块B获取到需要的数据才能正常运行，但是模块B还没有ready，那这种情况下如何测试模块A呢？这个时候就需要一个测试桩，用测试桩来模拟模块B响应模块A的请求。

尤其是一些新手，一听到测试桩，可能就懵逼了，觉得是一个超级高大上的东西。其实它的原理非常简单，几行代码就能搞定的事情。通常情况下，测试桩就是一个运行着的普通http/https服务，本身没有业务逻辑，仅仅被动响应被测试系统的请求，返回预定义的结构化的测试数据。这里听上去比较拗口，但是感觉也不太好用人话表述，直接上图吧。

这里一定要弄清楚谁是被测试系统，谁是测试桩，之前在评审一个测试的时候，发现一个员工稀里糊涂废了半天劲，把被测试系统给模拟掉了，自动化用例直接调用测试桩，我当时想死的心都有了。



## class Mock(CallableMixin, NonCallableMock)
创建新的Mock对象。Mock采用几个可选参数来指定Mock对象的行为：

1. spec: 
   1. 这可以是字符串列表，也可以是作为模拟对象规范的现有对象（类或实例）。
   2. 如果传入一个对象，则通过对该对象调用dir来形成字符串列表（不包括不支持的魔术属性和方法）。访问不在此列表中的任何属性都将引发AttributeError。
   3. 如果spec是一个对象（而不是字符串列表），那么 `mock.__class__` 返回 spec 对象的类。这允许 mock 通过 isinstance 测试。
2. spec_set: 
   1. spec的一个更严格的变体。如果使用，尝试在mock上设置或获取一个属性，而该属性不在作为 spec_set 传递的对象上，将引发AttributeError。
3. side_effect: 
   1. 每当调用 Mock 时要调用的函数。用于`引发异常`或`动态更改返回值`。使用与mock相同的参数调用函数，除非它返回 DEFAULT ，否则将使用此函数的返回值作为返回值。
   2. 如果副作用是可迭代的，那么每个对 mock 的调用都将返回 iterable 的下一个值。如果iterable的任何成员是异常，则将引发它们而不是返回它们。

4. return_value: 
   1. 调用mock时返回的值。默认情况下，这是一个新的Mock（在第一次访问时创建）。请参见“返回值”属性。

5. wraps: 要包装的模拟对象的项。
   1. 如果wrapps不是None，那么调用Mock将把调用传递给wrapped对象（返回真实结果）。对mock的属性访问将返回一个mock对象，该对象包装了包装对象的相应属性（因此尝试访问不存在的属性将引发AttributeError）。
   2. 如果 mock 设置了一个显式的 return_value ，则调用不会传递给包装对象，而是返回 return_value。

6. name: 
   1. 如果mock有一个名称，那么它将在mock的repr中使用。这对调试很有用。该名称将传播到子mock。





