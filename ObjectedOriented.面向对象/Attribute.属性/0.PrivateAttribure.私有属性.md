# PrivateAttribure.私有属性

* 对于私有变量， 如果从外部强行对私有变量进行操作，如果直接在外部直接用类内部定义的私有变量名进行操作的话，此时并不是直接对类中的私有变量做操作，而是为对象添加了一个新的属性。 
* 原有的私有变量名的实际名称是被修改为_ClassNamePrivateVar，如Student类中的一个私有变量名为__score，实际会被重命名成为_Student__score。
* 也可以直接使用_ClassNamePrivateVar来直接操作私有变量，可是不推荐这样。


## 流畅的python

Python 不能像 Java 那样使用 private 修饰符创建私有属性，但是 Python 有个简单的机制，能避免子类意外覆盖“私有”属性。

举个例子。有人编写了一个名为 Dog 的类，这个类的内部用到了 mood 实例属性，但是没有将其开放。现在，你创建了 Dog 类的子类：Beagle。如果你在毫不知情的情况下又创建了名为 mood 的实例属性，那么在继承的方法中就会把 Dog 类的 mood 属性覆盖掉。这是个难以调试的问题。

为了避免这种情况，如果以 `__mood` 的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的 `__dict__` 属性中，而且会在前面加上一个下划线和类名。因此，对 Dog 类来说， `__mood` 会变成 `_Dog__mood` ；对 Beagle 类来说，会变成 `_Beagle__mood` 。这个语言特性叫名称改写（name mangling）。


示例 9-10　私有属性的名称会被“改写”，在前面加上下划线和类名
```py
>>> v1 = Vector2d(3, 4)
>>> v1.__dict__
{'_Vector2d__y': 4.0, '_Vector2d__x': 3.0}
>>> v1._Vector2d__x
3.0
```


只要知道改写私有属性名的机制，任何人都能直接读取私有属性——这对调试和序列化倒是有用。此外，只要编写 v1._Vector__x = 7 这样的代码，就能轻松地为 Vector2d 实例的私有分量直接赋值。如果真在生产环境中这么做了，出问题时可别抱怨。

绝对不要使用两个前导下划线，这是很烦人的自私行为。如果担心名称冲突，应该明确使用一种名称改写方式（如 _MyThing_blahblah）。这其实与使用双下划线一样，不过自己定的规则比双下划线易于理解。


Python 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 Python 程序员严格遵守的约定，他们不会在类外部访问这种属性。 遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。  
不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对 from mymod import * 来说，mymod 中前缀为下划线的名称不会被导入。然而，依旧可以使用 from mymod import _privatefunc 将其导入。Python 教程的 6.1 节“More on Modules”（https://docs.python.org/3/tutorial/modules.html#more-on-modules）说明了这一点。







## ref
* [流畅的python] 9.7
* 
