# mock

* py3已将mock集成到unittest库中
* 为的就是更好的进行单元测试
* 简单理解，模拟接口返回参数
* 通俗易懂，直接修改接口返回参数的值
* [官方文档](https://docs.python.org/zh-cn/3/library/unittest.mock.html)

## Mock概念
Mock:模拟部分功能实现,伪实现,接口测试时,可以实现伪接口

## Mock作用
1. 可以解除一些第三方依赖关系,方便测试
   1. 当我们测试某个目标接口（模块）时，该接口依赖其他接口，当被依赖的接口未开发完成时，可以用mock模拟被依赖接口，完成目标接口的测试
2. 模拟复杂业务的接口
   1. 模拟程序中出现的一些异常,尤其是小概率的异常事件(并发实现时,异常抛出是小概率)
   2. 当我们测试某个目标接口（模块），该接口依赖一个非常复杂的接口时，可以用mock来模拟这个复杂的业务接口；也解决接口依赖一样的原理
3. 单元测试
   1. 由于前后端开发进度不一致，如果前段开发速度快于后端，这时候需要一个假的接口用于模拟后端返回
4. 前后端联调
   1. 由于项目需要用到第三方接口，如果第三方接口未开发完成或者第三方接口没有测试环境，为了保证进度，需要模拟接口调试

## Mock实现方式
1. 白盒: 修改代码
2. 黑盒: 创建 Mock 服务, 让 Mock 服务模拟接口实现

##  Python Mock实现
1. 安装Mock, pip install mock( Python3.3之前需要安装,之后整合进 unittest了)
2. 确定被模拟的接口功能
3. 创建mock对象,设置被模拟的接口的返回数据
4. 调用,调用时调用mock对象


## 测试桩
有时候，在测试过程中，可能会用到测试桩。举个例子，模块A是我们的被测试系统，但是模块A需要从模块B获取到需要的数据才能正常运行，但是模块B还没有ready，那这种情况下如何测试模块A呢？这个时候就需要一个测试桩，用测试桩来模拟模块B响应模块A的请求。

尤其是一些新手，一听到测试桩，可能就懵逼了，觉得是一个超级高大上的东西。其实它的原理非常简单，几行代码就能搞定的事情。通常情况下，测试桩就是一个运行着的普通http/https服务，本身没有业务逻辑，仅仅被动响应被测试系统的请求，返回预定义的结构化的测试数据。这里听上去比较拗口，但是感觉也不太好用人话表述，直接上图吧。

这里一定要弄清楚谁是被测试系统，谁是测试桩，之前在评审一个测试的时候，发现一个员工稀里糊涂废了半天劲，把被测试系统给模拟掉了，自动化用例直接调用测试桩，我当时想死的心都有了。



## class Mock(CallableMixin, NonCallableMock)
创建新的Mock对象。Mock采用几个可选参数来指定Mock对象的行为：
1. spec: 
   1. 这可以是字符串, 列表，也可以是作为模拟对象规范的现有对象（类或实例）。
   2. 如果传入一个对象，则通过对该对象调用dir来形成字符串列表（不包括不支持的魔术属性和方法）。访问不在此列表中的任何属性都将引发AttributeError。
   3. 如果spec是一个对象（而不是字符串列表），那么 `mock.__class__` 返回 spec 对象的类。这允许 mock 通过 isinstance 测试。
2. spec_set: 
   1. spec的一个更严格的变体。如果使用，尝试在mock上设置或获取一个属性，而该属性不在作为 spec_set 传递的对象上，将引发AttributeError。
3. side_effect: 
   1. 每当调用 Mock 时要调用的函数。用于`引发异常`或`动态更改返回值`。使用与mock相同的参数调用函数，除非它返回 DEFAULT ，否则将使用此函数的返回值作为返回值。
   2. 它必须是一个iterator（列表），它会覆盖 return_value
   3. 如果副作用是可迭代的，那么每个对 mock 的调用都将返回 iterable 的下一个值。如果iterable的任何成员是异常，则将引发它们而不是返回它们。
4. return_value: 
   1. 调用mock时返回的值。默认情况下，这是一个新的Mock（在第一次访问时创建）。请参见“返回值”属性。
   2. 它可以是一个值，可以是一个对象（如果存在side_effect参数那这个就没有用，也就是不能同时用）
5. wraps: 要包装的模拟对象的项。
   1. 如果wrapps不是None，那么调用Mock将把调用传递给wrapped对象（返回真实结果）。对mock的属性访问将返回一个mock对象，该对象包装了包装对象的相应属性（因此尝试访问不存在的属性将引发AttributeError）。
   2. 如果 mock 设置了一个显式的 return_value ，则调用不会传递给包装对象，而是返回 return_value。
6. name: 
   1. 如果mock有一个名称，那么它将在mock的repr中使用。这对调试很有用。该名称将传播到子mock。


## mock装饰器
一共两种格式
* `@patch('module名字.方法名')`
* `@patch.object(类名, '方法名')`
